#+Title: Trees
#+startup: fold
#+name: org-clear-haskell-output
#+begin_src emacs-lisp :var strr="" :exports none
(format "%s" (replace-regexp-in-string (rx (and (| "*Main" "Prelude") (? "|") (? white) (? ">") (? white))) "" (format "%s" strr)))
#+end_src

#+RESULTS: org-clear-haskell-output

* Trees
  In this file we will define trees and some related functions
** Binary Tree
*** Type
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      data BinTree a
        = EmptyTree
        | Node a (BinTree a) (BinTree a)

      
      instance Show a => Show (BinTree a) where
        show EmptyTree = " ()"
        show (Node a left right) = " (" ++ (show a) ++ (show left) ++ (show right) ++ ")"
      :}
 #+end_src

 #+RESULTS:
*** Create single node (leaf)
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      leafBT :: a -> BinTree a  
      leafBT a = Node a EmptyTree EmptyTree
      
      :}
#+end_src

#+RESULTS:
*** Insert node
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      insertNodeBT :: (Ord a) => BinTree a -> a -> BinTree a
      insertNodeBT EmptyTree value = leafBT value
      insertNodeBT tree value
          | value == nodeValue = Node value left right
          | value < nodeValue  = Node nodeValue (insertNodeBT left value) right
          | value > nodeValue  = Node nodeValue left (insertNodeBT right value)
          where (Node nodeValue left right) = tree
      
      :}
#+end_src

#+RESULTS:
