#+Title: Trees
#+startup: fold
#+name: org-clear-haskell-output
#+begin_src emacs-lisp :var strr="" :exports none
  (format "%s"
          (replace-regexp-in-string (rx (and (| "*Main" "Prelude")
                                             (? "|")
                                             (? ">")
                                             ))
                                    ""
                                    (format "%s" strr)))
  
#+end_src

#+RESULTS: org-clear-haskell-output

In this file we will define trees and some related functions

** Binary Tree
*** Type
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      data BinTree a
        = EmptyTree
        | Node a (BinTree a) (BinTree a)
      
      
      instance Show a => Show (BinTree a) where
        show EmptyTree = " _"
        show (Node a left right) = " (" ++ (show a) ++ (show left) ++ (show right) ++ ")"
      
      instance Functor BinTree  where
        fmap f EmptyTree = EmptyTree 
        fmap f (Node a left right) = Node (f a) (fmap f left) (fmap f right)
      
      :}
    #+end_src

    #+RESULTS:
*** Create single node (leaf)
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      leafBT :: a -> BinTree a  
      leafBT a = Node a EmptyTree EmptyTree
      
      :}
    #+end_src

    #+RESULTS:
*** Insert node
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      
      insertNodeBT :: (Ord a) => BinTree a -> a -> BinTree a
      insertNodeBT EmptyTree value = leafBT value
      insertNodeBT tree value
          | value == nodeValue = Node value left right
          | value < nodeValue  = Node nodeValue (insertNodeBT left value) right
          | value > nodeValue  = Node nodeValue left (insertNodeBT right value)
          where (Node nodeValue left right) = tree
      
      :}
    #+end_src

    #+RESULTS:
*** Executing functions
**** Creating a leaf
     #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
       leafBT 10
     #+end_src

     #+RESULTS:
     : (10 _ _)

     #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
       leafBT  "string node"
     #+end_src

     #+RESULTS:
     : (string node _ _)

**** Creating a binary tree from a list
     #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
       foldl insertNodeBT EmptyTree [5, 4, 6, 3 , 1, 9, 8]
#+end_src

#+RESULTS:
: (5 (4 (3 (1 _ _) _) _) (6 _ (9 (8 _ _) _)))

**** Applying fmap on a tree, i.e. trees as functors
     #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
       tree = foldl insertNodeBT EmptyTree [5, 4, 6, 3 , 1, 9, 8]
       fmap (* 10) tree       
#+end_src

#+RESULTS:
: (50 (40 (30 (10 _ _) _) _) (60 _ (90 (80 _ _) _)))
