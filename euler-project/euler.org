#+Title: Project Euler
#+startup: logdone fold
#+TODO: TODO HASKELL CLOJURE | DONE
#+PROPERTY: LOGGING nil
#+name: org-clear-haskell-output
#+begin_src emacs-lisp :var strr="" :exports none
  (format "%s" (replace-regexp-in-string (rx (and (+ (| letter ".")) (? "|") (? white) (? ">") (? white))) "" (format "%s" strr)))
#+end_src


#+name: org-clear-clojure-output
#+begin_src emacs-lisp :var strr="" :exports none
  (replace-regexp-in-string (rx (| (and "(#'user" (+ (not ")")) ")" (+ white)) (and line-start "(") (and ")" line-end))) "" (format "%s" strr))
#+end_src



* Problems 1 to 10
** DONE Multiples of 3 and 5
   Find the sum of all the multiples of 3 or 5 below 1000.

*** Haskell
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      sum $ [x | x <- [1..1000], mod x 3 == 0 , mod x 5 == 0]
    #+end_src

    #+RESULTS:
    : 33165

*** Clojure
    #+begin_src clojure :exports both 
      (apply +
             (filter (fn [x] (and (= 0 (mod x 5))
                                  (= 0 (mod x 3))))
                     (range 1 1000)))
    #+end_src

    #+RESULTS:
    : 33165
   
** DONE Even Fibonacci numbers
   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

   By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

*** Haskell   
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      :{
      fibRec :: [Int] -> [Int]
      fibRec list@(x:y:xs) =
        if x >= 4000000
          then (y : xs)
          else fibRec ((x + y) : list)
      :}
      sum $ filter even $ fibRec [2, 1]
    #+end_src

    #+RESULTS:
    : 4613732

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (defn fib-rec [lst]
        (let [[a b] lst]
          (if (>= (+ a b) 4000000) lst
              (fib-rec (cons (+ a b) lst)))))

      (defn fib
        "returns the reversed list of the n first fib numbers such that n < 4mi"
        []
        (fib-rec [2 1]))

      (apply + (filter even? (fib)))
    #+end_src

    #+RESULTS:
    : (4613732)

** TODO Largest prime factor
   The prime factors of 13195 are 5, 7, 13 and 29.

   What is the largest prime factor of the number 600851475143 ?
*** Haskell   
*** Clojure
** DONE Largest palindrome product
   A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

   Find the largest palindrome made from the product of two 3-digit numbers.

*** Haskell   
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      isPalindrome n = (show n) == (reverse $ show n)
      set = reverse $ [100..999]
      head $ [(a*b, a, b) | a<-set, b<-set, isPalindrome (a * b)]
    #+end_src

    #+RESULTS:
    : (580085,995,583)

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (defn is-palindrome [n]
        (= (str n) (apply str (reverse (str n)))))

      (first
       (for [x (reverse (range 100 999))
             y (reverse (range 100 999))
             :let [z (* x y)]
             :when (is-palindrome z)]
         [z x y]))
    #+end_src

    #+RESULTS:
    : ([580085 995 583])

** DONE Smallest multiple
   2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

   What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

*** Haskell   
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      gcd :: Int -> Int -> Int
      gcd a b =
        if a == 0
          then b
          else gcd (mod b a) a

      lcmBin :: Int -> Int -> Int
      lcmBin a b = div (a * b) (gcd a b)

      foldl lcmBin 1 [1..20]

    #+end_src

    #+RESULTS:
    : 232792560

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (def gcd
        (fn [num1 num2]
          (loop [a num1 b num2]
            (if (zero? a) b
                (recur (mod b a) a)))))

      (defn lcm-bin [a b]
        (/ (* a b) (gcd a b)))

      (reduce lcm-bin 1 (range 1 21))

    #+end_src

    #+RESULTS:
    : (232792560)

** DONE Sum square difference
   The sum of the squares of the first ten natural numbers is 1^2 + 2^2 + ... + 10^2 = 385

   The square of the sum of the first ten natural numbers is (1 + ... + 10)^2 = 3025

   Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.

   Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

*** Haskell   
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      square :: Int -> Int
      square x = x * x

      sumOfSquares :: [Int] -> Int
      sumOfSquares = sum . map square 

      squareOfSum :: [Int] -> Int
      squareOfSum = square . sum

      squareOfSum [1..100] - sumOfSquares [1..100]
    #+end_src

    #+RESULTS:
    : 25164150

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (defn square [x] (* x x))

      (defn sum-of-squares [lst]
        (apply + (map square lst)))

      (defn square-of-sum [lst]
        (square (apply + lst)))

      (- (square-of-sum (range 1 101))
         (sum-of-squares (range 1 101)))
    #+end_src

    #+RESULTS:
    : (25164150)

** TODO 10001st prime
   By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

   What is the 10 001st prime number?
*** Haskell
*** Clojure   
** DONE Largest product in a series
   The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

   73167176531330624919225119674426574742355349194934
   96983520312774506326239578318016984801869478851843
   85861560789112949495459501737958331952853208805511
   12540698747158523863050715693290963295227443043557
   66896648950445244523161731856403098711121722383113
   62229893423380308135336276614282806444486645238749
   30358907296290491560440772390713810515859307960866
   70172427121883998797908792274921901699720888093776
   65727333001053367881220235421809751254540594752243
   52584907711670556013604839586446706324415722155397
   53697817977846174064955149290862569321978468622482
   83972241375657056057490261407972968652414535100474
   82166370484403199890008895243450658541227588666881
   16427171479924442928230863465674813919123162824586
   17866458359124566529476545682848912883142607690042
   24219022671055626321111109370544217506941658960408
   07198403850962455444362981230987879927244284909188
   84580156166097919133875499200524063689912560717606
   05886116467109405077541002256983155200055935729725
   71636269561882670428252483600823257530420752963450

   Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

*** Haskell
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      import Data.Char (digitToInt)
      :{
      arr =
        map digitToInt $
        show
          7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

      calcMax :: [Int] -> Int -> Int
      calcMax list currMax = max currMax $ foldl (*) 1 list

      reducer :: (Int, [Int]) -> Int -> (Int, [Int])
      reducer (currMax, lst) _ =
        if (length lst) < 13
          then (currMax, lst)
          else (calcMax chunk currMax, rest)
        where chunk = take 13 lst
              rest = drop 13 lst

      :}
      fst $ foldl reducer (0, arr) arr
    #+end_src

    #+RESULTS:
    : 6270566400

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (def n 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)

      (def arr (map (comp #(Integer/valueOf %) str) (str n)))

      (first
       (reduce
        (fn [[currMax, lst] _]
          (if (< (count lst) 13) [currMax lst]
              (let [chunk (take 13 lst)
                    rest (drop 13 lst)
                    mul (apply * chunk)]
                [(max mul currMax) rest])))
        [0, arr]
        arr))

    #+end_src

    #+RESULTS:
    : (6270566400)

** DONE Special Pythagorean triplet
   A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

   a^2 + b^2 = c^2

   There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   Find the product abc.

*** Haskell
    #+begin_src haskell :exports both :post org-clear-haskell-output(*this*)
      set = [1..1000]
      head $ [ a*b*c | a<-set, b<-set, c<-set, a+b+c==1000, a^2+b^2==c^2, a < b, b < c]
    #+end_src

    #+RESULTS:
    : 31875000

*** Clojure
    #+begin_src clojure :exports both :post org-clear-clojure-output(*this*)
      (defn is-correct [a b c]
        (and
         (< a b)
         (< b c)
         (= 1000 (+ a b c))
         (= (* c c) (+ (* a a) (* b b)))))

      (apply *
             (first
              (for [x (range 1 1001)
                    y (range 1 1001)
                    z (range 1 1001)
                    :let [a x b y c z]
                    :when (is-correct a b c)]
                [a b c])))

    #+end_src

    #+RESULTS:
    : (31875000)

** TODO Summation of primes
   The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

   Find the sum of all the primes below two million.
*** Haskell
*** Clojure
